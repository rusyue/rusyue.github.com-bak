<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用AHK提高Windows下的工作效率]]></title>
    <url>%2F2018%2F02%2F20%2F%E4%BD%BF%E7%94%A8AHK%E6%8F%90%E9%AB%98Windows%E4%B8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[快捷键 功能描述 快捷键 功能描述 m Ctrl + S - 保存 , 鼠标左键 n Ctrl + Z - 撤销 q 鼠标左键 z Ctrl + Z - 撤销 . 鼠标右键 y Ctrl + Y - 重做 e 鼠标右键 c Ctrl + C - 复制 r 滚轮向上 v Ctrl + V - 粘贴 f 滚轮向下 x Ctrl + X - 剪切 h 退格键 t PageUp - 向上翻页 u Home - 光标至行首 g PageDown - 向下翻页 o End - 光标至行尾 w 向上移动鼠标 i Up - 光标上移 d 向右移动鼠标 l Right - 光标右移 s 向下移动鼠标 k Down - 光标下移 a 向左移动鼠标 j Left - 光标左移 shift + w 向上快速移动鼠标 F9 重载脚本 shift + d 向右快速移动鼠标 F10 编辑脚本 shift + s 向下快速移动鼠标 F11 挂起脚本 shift + a 向左快速移动鼠标 F12 暂停脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109; =======================================; 单击 CapsLock 键切换键盘鼠标; 长按 CapsLock 键切换大写锁定; =======================================$CapsLock::KeyWait, CapsLockIf (A_PriorKey &lt;&gt; "CapsLock") returnIf (A_TimeSinceThisHotkey &gt; 300)&#123; SetCapsLockState, % GetKeyState("CapsLock", "T") ? "Off" : "On" ; Tip("大写锁定: " . (GetKeyState("CapsLock", "T") ? "开启" : "关闭")) ShowTIPS("大写锁定: " . (GetKeyState("CapsLock", "T") ? "开启" : "关闭"))&#125;Else&#123; CapsLockMode := !CapsLockMode ; Tip(CapsLockMode ? "CapsLockMode" : "", "INF", 20, 0, 600) ; TIP("键盘鼠标: " . (CapsLockMode ? "开启" : "关闭")) ShowTIPS("键盘鼠标: " . (CapsLockMode ? "开启" : "关闭")) SetTimer, Beep, -300 If CapsLockMode SetTimer, CapsLockModeTimeOut, 2500 Else SetTimer, CapsLockModeTimeOut, Off&#125;ReturnCapsLockModeTimeOut:; ShowTIPS("键盘鼠标: " . A_TimeSinceThisHotkey)If (A_TimeSinceThisHotkey &lt; 5000) returnSetTimer, CapsLockModeTimeOut, OffCapsLockMode := !CapsLockModeShowTIPS("键盘鼠标: " . (CapsLockMode ? "开启" : "超时"))SetTimer, Beep, -300Return; =================================================================; 按住 CapsLock 键、或者 键盘鼠标 开启时，有如下快捷键：; =================================================================; | 快捷键 | 功能描述 | 快捷键 | 功能描述 |; | :-------: | :-----------------: | :----: | :---------------: |; | m | Ctrl + S - 保存 | , | 鼠标左键 |; | n | Ctrl + Z - 撤销 | q | 鼠标左键 |; | z | Ctrl + Z - 撤销 | . | 鼠标右键 |; | y | Ctrl + Y - 重做 | e | 鼠标右键 |; | c | Ctrl + C - 复制 | r | 滚轮向上 |; | v | Ctrl + V - 粘贴 | f | 滚轮向下 |; | x | Ctrl + X - 剪切 | h | 退格键 |; | t | PageUp - 向上翻页 | u | Home - 光标至行首 |; | g | PageDown - 向下翻页 | o | End - 光标至行尾 |; | w | 向上移动鼠标 | i | Up - 光标上移 |; | d | 向右移动鼠标 | l | Right - 光标右移 |; | s | 向下移动鼠标 | k | Down - 光标下移 |; | a | 向左移动鼠标 | j | Left - 光标左移 |; | shift + w | 向上快速移动鼠标 | F9 | 重载脚本 |; | shift + d | 向右快速移动鼠标 | F10 | 编辑脚本 |; | shift + s | 向下快速移动鼠标 | F11 | 挂起脚本 |; | shift + a | 向左快速移动鼠标 | F12 | 暂停脚本 |; =================================================================; 需要更多快捷键的话自己添加到下面两个 #If 之间……; =================================================================#If CapsLockMode Or GetKeyState("CapsLock", "P")Up::MouseMove, 0, -1, 0, R ;w::Send, &#123;Up&#125;Left::MouseMove, -1, 0, 0, R ;a::Send, &#123;Left&#125;Down::MouseMove, 0, +1, 0, R ;s::Send, &#123;Down&#125;Right::MouseMove, +1, 0, 0, R ;d::Send, &#123;Right&#125;,::LButtonq::LButton.::RButtone::RButtonr::MouseClick, WheelUp, , , 3f::MouseClick, WheelDown, , , 3t::PgUpg::Pgdni::Upl::Rightk::Downj::Lefth::Backspaceu::Homeo::Endw::MoveCursor("w", 1)a::MoveCursor("a")s::MoveCursor("s", 1)d::MoveCursor("d")+w::MoveCursor("w", 80)+a::MoveCursor("a", 80)+s::MoveCursor("s", 80)+d::MoveCursor("d", 80)m::^sn::^zy::^yz::^zc::^cv::^vx::^xF9::ReloadF10::EditF11::SuspendF12::Pause#IfBeep:SoundBeep, CapsLockMode ? 1900 : 600, 100Return]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>AHK</tag>
        <tag>AutoHotkey</tag>
        <tag>Tools</tag>
        <tag>工具</tag>
        <tag>脚本</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Meting & APlayer]]></title>
    <url>%2F2018%2F02%2F17%2FMeting%2F</url>
    <content type="text"><![CDATA[Meting Requirementhttps://github.com/MoePlayer/APlayer CDNhttps://cdn.jsdelivr.net/npm/meting/dist/Meting.min.jshttps://unpkg.com/meting/dist/Meting.min.js Quick Start12345678&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.6.0/APlayer.min.js"&gt;&lt;/script&gt;&lt;div class="aplayer" data-id="60198" data-server="netease" data-type="playlist"&gt;&lt;/div&gt;&lt;script src="dist/Meting.min.js"&gt;&lt;/script&gt; https://music.163.com/#/playlist?id=60198 Option option default description data-id require song id / playlist id / album id / search keyword data-server require music platform: netease, tencent, kugou, xiami, baidu data-type require song, playlist, album, search, artist data-mode circulation play mode, circulation, random, single, order data-autoplay false autoplay song(s), not supported by mobile browsers data-mutex true pause other players when this player playing data-listmaxheight 340px max height of play list data-preload auto the way to load music, can be none, metadata, auto data-theme #ad7a86 theme color more https://aplayer.js.org/docs/#/?id=options AdvancedUse self music API, see also https://github.com/metowolf/Meting 1234&lt;script&gt;var meting_api='http://example.com/api.php?server=:server&amp;type=:type&amp;id=:id&amp;r=:r';&lt;/script&gt;&lt;script src="dist/Meting.min.js"&gt;&lt;/script&gt; AuthorMetingJS © metowolf, Released under the MIT License. Blog @meto · GitHub @metowolf · Twitter @metowolf · Telegram Channel @metooooo APlayer Wow, such a lovely HTML5 music player Introduction APlayer is a lovely HTML5 music player to help people build audio easily. APlayer supports: Media formats MP4 H.264 (AAC or MP3) WAVE PCM Ogg Theora Vorbis Features Playlist Lyrics Using APlayer on your project? Let me know! Demo Docs Install1$ npm install aplayer --save Quick Start12&lt;div id="aplayer1" class="aplayer"&gt;&lt;/div&gt;&lt;script src="dist/APlayer.min.js"&gt;&lt;/script&gt; 12345678var ap = new APlayer(&#123; element: document.getElementById('aplayer1'), music: &#123; title: 'Preparation', author: 'Hans Zimmer/Richard Harvey', url: 'Preparation.mp3', &#125;&#125;); UsageRead the Docs CDN jsDelivr cdnjs unpkg Join the Discussion Telegram Group QQ Group: 415835947 Related Projects APlayer-Typecho-Plugin hexo-tag-aplayer 163music-APlayer-you-get-docker Hermit-X(APlayer for WordPress) vue-aplayer APlayer_for_Z-BlogPHP php-aplayer react-aplayer vue-aplayer APlayer-Controler APlayerHandle MetingJS Feel free to submit yours in Let me know! Who use APlayer? 站长之家 TheFatRat Jelly Rue Justice_Eternal吧曲谱资源站 Justice_Eternal吧曲谱资源站(移动端) 歌词千寻 iSearch LRC歌词编辑器 LLSupport Аэростатика Feel free to submit yours in Let me know! Donate Donate via OpenCollective Donate via Paypal Donate via WeChat Pay Donate via Alipay Donate via Bitcoin: 13CwQLHzPYm2tewNMSJBeArbbRM5NSmCD1 SponsorThank you to all our sponsors! ContributorsThis project exists thanks to all the people who contribute. BackersThank you to all our backers! AuthorAPlayer © DIYgod, Released under the MIT License.Authored and maintained by DIYgod with help from contributors (list). Blog · GitHub @DIYgod · Twitter @DIYgod · Telegram Channel @awesomeDIYgod]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>音乐</tag>
        <tag>黑暗之魂</tag>
        <tag>DarkSouls</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深圳世界之窗]]></title>
    <url>%2F2018%2F02%2F16%2F%E6%B7%B1%E5%9C%B3%E4%B8%96%E7%95%8C%E4%B9%8B%E7%AA%97%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>图集</category>
      </categories>
      <tags>
        <tag>图集</tag>
        <tag>游记</tag>
        <tag>深圳</tag>
        <tag>世界之窗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[崩坏3 除夕活动]]></title>
    <url>%2F2018%2F02%2F12%2F%E5%B4%A9%E5%9D%8F3-%E9%99%A4%E5%A4%95%E6%B4%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[第一组 第二组 第一个 第一个 第二个 第二个 第三个 第三个 第四个 第四个 第五个 第五个 第六个 第六个 第十三个 第十三个 活动需要扫描二维码,浏览器不能解析本地二维码，所以临时传到这里用一下…… 自动点击 油猴子123456789101112131415161718192021222324252627// ==UserScript==// @name 崩坏3除夕活动自动点击// @namespace rusyue.com// @include *://event.bh3.com/bh3_2018spring_festival/friends*// @version 1// @grant none// ==/UserScript==var btn = document.createElement('button');btn.setAttribute('style', 'width: 100px; height: 30px; position: fixed; top: 10px; right: 10px; line-height: 30px; box-shadow: 1px 1px 1.6px 1.6px rgba(0,0,0,0.4); cursor: pointer; border-radius: 2px; color: #333;');btn.appendChild(document.createTextNode('开始点击'));btn.addEventListener('click', startClick, false);document.body.appendChild(btn);function startClick() &#123; var live = document.querySelector('.live'); var count = 0; var timer = null; live.click(); clearTimeout(timer); timer = setTimeout(function cb() &#123; live.click(); ++count &lt;= 750 &amp;&amp; setTimeout(cb, 5); &#125;, 3000);&#125; 控制台直接输入1234567891011;(function startClick() &#123; var live = document.querySelector('.live'); var count = 0; var timer = null; live.click(); clearTimeout(timer); timer = setTimeout(function cb() &#123; live.click(); ++count &lt;= 750 &amp;&amp; setTimeout(cb, 5); &#125;, 3000);&#125;()); 二维码]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>崩坏3</tag>
        <tag>手游</tag>
        <tag>二刺猿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Group pictures test]]></title>
    <url>%2F2018%2F02%2F11%2Fgroup-pictures-test%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>图集</category>
      </categories>
      <tags>
        <tag>图集</tag>
        <tag>相册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器背后的故事]]></title>
    <url>%2F2017%2F07%2F13%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[当服务器提供了资源资源（HTML css js images等），浏览器会执行下面的操作： 解析 —— HTML css js 渲染 —— DOM树 =&gt; render树 =&gt; 布局 =&gt; paint 浏览器的组成 UI 渲染引擎 浏览器引擎：UI与渲染引擎协调工作 网络组件：网络调用如 http等 js引擎：解析与执行js 数据存储：数据存储组件 HTML解析get DOM tree 渲染引擎从网络层取得请求的文档，8k/chunk进行传输 解析成DOM树 遇到外部资源标签，一边开始下载，一边继续解析 发生阻塞的情况： CSSOM阻塞js执行，js执行阻塞DOM构建 CSS解析get css rule tree 页面渲染 通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值 通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度 通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度 通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度 使用上面的计算结果构建每个节点的坐标 当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work 创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层 页面上的每个层都被分配了纹理(?) 每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制 上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量 计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>内核</tag>
        <tag>解析</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些坑死的人的巨坑]]></title>
    <url>%2F2017%2F07%2F13%2F%E9%82%A3%E4%BA%9B%E5%9D%91%E6%AD%BB%E4%BA%BA%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前端样式兼容common bitch 移动端经典搞事情案例：click300ms延迟（14年已被chrome剔除，现在的移动端基本没有这个坑爹现象） 原因：区分移动端单击、双击，故意做了300ms延迟，wtf ？14年的我已经开始入门切图仔了 T-T 解决： 禁止缩放 设置meta标签 fastclick 有些库已经做了封装，such as zepto的touch事件 不会有这种bug android bitch 现象：安卓qq浏览器 视频自动播放默认全屏 解决：微信浏览器可设置微信相关属性，如果适配要求高，推荐使用播放器插件 button 按下后有默认黄色边框 解决：outline: none 如果你想在移动端页面使用绝对定位布局？死了这条心吧，有input（输入）的地方，必死无疑！ 解决：乖乖用flex布局吧 ​ ios bitch 现象：iso 长文本不流畅，android 反而很流畅 解决： -webkit-overflow-scrolling: touch //当手指从触摸屏上移开，会保持一段时间的滚动 -webkit-overflow-scrolling: auto //当手指从触摸屏上移开，滚动会立即停止 现象：iOS safari微信浏览器等 :active 失效 解决：&lt;button ontouchstart=&quot;&quot;&gt;&lt;/button&gt; or &lt;body ontouchstart=&quot;&quot;&gt;&lt;/body&gt; // 想比较不利于性能 原因：移动端touch速度快到浏览器难以捕捉到行为的触发，手动增加touch事件，通知浏览器有touch事件 现象：input首写字母默认大写 解决：&lt;input type=&quot;text&quot; autocapitalize=&quot;none&quot;&gt; 现象：识别长串数字为tel 解决：添加meta js兼容问题只考虑高级浏览器跟移动端 混合开发兼容问题hybird bitch native webview功能相互迁移或者有相关的修改，需考虑版本兼容问题 webview h5导航问题 浏览器window对象下的有些方法的使用需要native支持，比如navigator、alert、localStorage等 ​ 后端 API若是跨域请求，若涉及cookie，需要注意： 需要设置携带cookie：Access-Control-Allow-credential: true origin： 与 设置携带cookie设置项冲突，origin不可设置]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>兼容</tag>
        <tag>CSS</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解格式块上下文(BFC)]]></title>
    <url>%2F2017%2F06%2F22%2F%E7%90%86%E8%A7%A3%E6%A0%BC%E5%BC%8F%E5%9D%97%E4%B8%8A%E4%B8%8B%E6%96%87(BFC)%2F</url>
    <content type="text"><![CDATA[在问格式块上下文之前，我们回顾一个问题： Q: 行与块的区别是什么？ A：主要是以下三个区别 块独占一行（最明显的区别） 可以容纳块或行为子元素 行元素不能设置height、line-height、margin-top、margin-bottom 开始进入主题 Q: 什么是格式块上下文？ A: 块级盒模型发生的区域… Q: 什么情况下会触发bfc？ A: 那情况就多了，个人常用元素罗列一下，不常用的不管了 ：） display: inline-block、flex、grid、table-cell等 float position: absolute、fixed overflow 触发BFC会有什么影响？ 在布局过程中，我们往往会使用float、flex、定位等来实现我们想要的布局，效果的实现伴随的副作用的出现，比如： 浮动对夫、兄元素带来的麻烦（夫：高度，兄：图文环绕） 合并外边距 Q：什么是合并外边距？ A：两个相邻盒子的外边距结合成一个单独的外边距的现象称为合并外边距，也叫折叠外边距 Q：怎么计算合并后的边距？ A：也是三种计算规则： 正正，边距取最大值 负负，边距取绝对值最大值 正负，边距取相加之和 Q：产生折叠的必要条件？ A：两个margin紧挨… Q：如何算是两个盒子margin边距紧挨？ A：敲黑板！ 必须是处于常规文档流的块级盒子，并且处在同一个BFC中 没有clearance，没有padding，border隔开 垂直方向上的外边距满足以下任意情况，即可召唤神龙 元素的margin-top与其第一个常规文档流的子元素的margin-top 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom Generally speaking 如何解决外边距折叠的问题？ clearance、给1px的padding或者margin 父子关系：父元素触发BFC，使子元素处于非常规文档流中 兄弟关系：按需求触发BFC inline-block：无论父子还是兄弟，都不会产生折叠边距 如何触发BFC ? 请爬楼，请爬楼… Over 日常随便写写…]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>盒模型</tag>
        <tag>BFC</tag>
        <tag>flex</tag>
        <tag>float</tag>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML DOCTYPE 标签]]></title>
    <url>%2F2017%2F06%2F02%2FHTML-DOCTYPE-%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML DOCTYPE 标签Doctype是什么？点击查看详解 &lt;!DOCTYPE&gt; 声明帮助浏览器正确地显示网页。 web世界中存在着很多不同的文档，只有了解了文档类型，浏览器才能正确的显示文档。这就是&lt;!DOCTYPE&gt;的用处。 &lt;!DoCTYPE&gt;并不是html标签，它为浏览器提供一项信息（声明），即HTML是什么版本编写的。 所有浏览器都支持 &lt;!DOCTYPE&gt;声明。实例带有 HTML5 DOCTYPE 的 HTML 文档：123456789&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title of the document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; The content of the document...... &lt;/body&gt;&lt;/html&gt; HTML 发展版本从 Web 诞生早期至今，已经发展出多个 HTML 版本： 版本 年份 HTML 1991 HTML+ 1992 HTML2.0 1995 HTML3.2 1997 HTML 4.01 1999 XHTML 1.0 2000 HTML5 2012 XHTML5 2013 定义和用法 提示：请始终向 HTML 文档添加&lt;!DOCTYPE&gt;声明，这样浏览器才能获知文档类型。 &lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于标签之前 &lt;!DOCTYPE&gt; 不是html标签，它是只是web浏览器关于使用哪个HTML版本经行编写的指令 在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。 HTML5 不基于 SGML，所以不需要引用 DTD。 HTML 4.01 与 HTML5 之间的差异在 HTML 4.01 中有三种 &lt;!DOCTYPE&gt; 声明。在 HTML5 中只有一种：1&lt;!DOCTYPE html&gt; 点击查看HTML 元素表，其中列出了每种元素会出现在哪个文档类型中。 提示和注释 注释：&lt;!DOCTYPE&gt; 声明没有结束标签。 提示：&lt;!DOCTYPE&gt; 声明对大小写不敏感。 提示：请使用 W3C 的验证器来检查您是否编写了有效的 HTML / XHTML 文档！####常用的 DOCTYPE 声明HTML51&lt;!DOCTYPE html&gt; HTML 4.01 Strict该DTD包含所有html元素和属性，但不包括展示性和启用的元素（如font）,不允许框架Framesets。1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; HTML 4.01 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; HTML 4.01 Frameset该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。1&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; XHTML 1.0 Strict该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; XHTML 1.0 Transitional该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; XHTML 1.0 Frameset该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt; XHTML 1.1该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>兼容</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6模块化温故知新]]></title>
    <url>%2F2017%2F05%2F29%2FES6%E6%A8%A1%E5%9D%97%E5%8C%96%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%2F</url>
    <content type="text"><![CDATA[ES6 Module概述 （没啥知新的，主要就是温故，就是整体过一遍） 对于js模块化这点内容，我觉得其实有点坑的，CommonJS + ES6自身的模块化机制，让很多新入门的同学傻傻分不清楚。 模块化是每种语言都有的功能，就连css都有@import，但是ES6之前没有原生的api支持，除非使用CommonJS 或者 AMD，成为客户端跟服务端的模块化解决方案。 ES6延用的是CommonJS的规范，但是有别与CommonJS。 尽量的静态化 代码块 动态绑定输出值，CommonJS对输出值缓存，es6及时更新 因为CommonJS“运行时加载”的特性，使得其运行后才能得到这个对象，注意是 一个对象，但ES6的设计思想是尽量的静态化，es6的模块不是一个对象，而是通过export 再 import之后的 代码块，使得在编译时就完成了加载。 命令exportexport可输出的类型 变量、函数、类 1234567891011121314// 变量var firstName = 'Ding';var lastName = 'Issac';export &#123;firstName, lastName&#125;;// 函数 或 类export multiply = function (x, y) &#123; return x * y;&#125;// 输出默认变量或者方法export default function () &#123; console.log('foo');&#125; 默认default 命令注意点： 一个模块只能有一个默认输出 import 可以不加大括号 声明变量必须在export default 之前 export default 也可以输出类 import import会执行所加载的模块 import命令具有提升效果，编译阶段会提升到整个模块的头部 12import &#123; lastName as surname &#125; from './profile.js'import customName from './export-default' // 引入默认类 整体加载模块123456789// 逐一加载import &#123; area, circumference &#125; from './circle'console.log('圆面积：' + area(4))console.log('圆周长：' + circumference(14))// 整体加载import * as circle from './circle';// blablabla 同上 按需加载 import()由于import 编译时加载，有一个提案，建议引入import()函数，完成动态加载 举个🌰 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); 动态加载 区别于node require import 异步加载，require 同步 使用场合： 按需加载 123456789button.addEventListener('click', event =&gt; &#123; import('./dialogBox.js') .then(dialogBox =&gt; &#123; dialogBox.open(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)&#125;); ​ 条件加载 12345if (condition) &#123; import('moduleA').then(...);&#125; else &#123; import('moduleB').then(...);&#125; ​ 动态的模块路径 12import(f()).then(...); 注意点： import() 模块加载成功后，作为一个对象，当作then方法中的参数。 import() 也可以用在async函数中 123456789101112async function main() &#123; const myModule = await import('./myModule.js'); const &#123;export1, export2&#125; = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);&#125;main();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的类型转换]]></title>
    <url>%2F2017%2F05%2F23%2FJS%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[值 转字符串 数字 布尔值 对象 undefined ‘undefined’ 0 false throws TypeError null ‘null’ 0 false throws TypeError true ‘true’ 1 new Boolean(true) false ‘false’ 0 new Boolean(false) ‘’ (空字符串) 0 false new String(‘’) ‘1.2’(数字字符串) 1.2 true new String(‘1.2’) ‘shiny’(非数字字符串) NaN true new String(‘shiny’) 0 ‘0’ false new Number(0) -0 ‘0’ false new Number(-0) Infinity ‘Infinity’ true new Number(Infinity) -Infinity ‘-Infinity’ true new Number(-Infinity) 33 ‘33’ true new Number(33) {} (任意对象) true new Number(NaN) [] ‘’ 0 true new Number(NaN) [33] ‘33’ 33 true new Number(NaN) [‘a’] ‘a’ NaN true new Number(NaN) function(){} NaN true new Number(NaN) 原始值转对象很简单，原始值通过调用String()，Number()，Boolean()构造函数，转换为他们各自的包装对象。null和undefined属于例外，当将他们用在期望是一个对象的地方都会造成一个类型错误(TypeErroe)异常，而不会执行正常的转换。 对象转换相对复杂，下面具体描述 转换和相等性由于JS可以做灵活的类型转换，因此其==相等运算符也随相等的含义灵活多变。例如：1234null == undefined // 这两值被认为相等'0' == 0 // 前面的字符串转为了数字 0 == false // 比较之前布尔值转成了数字'0' == false // 比较前字符串和布尔值都转成了数字 ==一个值转换为另一个值并不意味着两个值相等。比如，如果在期望使用布尔值的地方使用了undefined，它将会转换为false，但这并不表明undefined == false。JS运算符和语句期望使用多样化的数据类型，并可以相互转换。if语句将undefined转换为false，但==运算符从不试图将其操作数转换为布尔值。 相等运算符==比较并不严格。如果两个操作数不是同一类型，那么相等运算符会尝试进行一些类型转换，然后进行比较： 如果两个操作数的类型相同，则根据值进行比较，也就是类似于严格相等(===)进行比较。 如果两个操作数类型不同，==相等操作符也可能会认为他们相等。检测相等将会遵守如下规则和类型转换：1、如果一个值是null，另一个是undefined，则它们相等。2、如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。3、如果其中一个值是true，则将其转为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较。4、如果一个值是对象，另一个值是数字或字符串，则将对象转为原始值，然后再进行比较。对象通过toString()方法或者valueOf()方法转换为原始值。JS语言核心的内置首先尝试使用valueOf()，再尝试使用toString()，除了日期类，日期类只是用toString()转换。那些不是JS语言核心中的对象则通过各自的实现中定义的方法转换为原始值。5、其他不同类型之间的比较均不相等。 显示类型转换 做显示类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数。当不通过new运算符调用这些函数时，它们会作为类型转换函数：1234Number('3') // =&gt; 3String(false) // =&gt; 'false'Boolean([]) // =&gt; trueObject(3) // =&gt; new Number(3) 需要注意的是，除了null或undefined之外的任何值都具有toString()方法，这个方法执行结果通常和String()方法的返回结果一致。 JS中某些运算符会做隐式的类型转换，又是用户类型转换。 1234567x+'' // 等价于String('x')+x // 等价于Number(x).也可以写成x-0!!x // 等价于Boolean(x).注意是双叹号。10+'shiny' // '10shiny',数字10转换为字符串'7'*'4' // 28，两个字符串均转换为数字var n = 1 - 'x' // NaN: 字符串x无法转换为数字n + 'shiny' // 'NaN shiny': NaN转换为字符串NaN Number类定义的toString()方法可以接收表示转换基数(radix)的可选参数，如果不指定此参数，转换规则将是基于十进制。 1234var n = 17;var a = n.toString(2); // 转化为 ‘10001’var b = '0' + n.toString(8); // 转换为‘021’var c = '0x' + n.toString(16); // 转换为‘0x11' 如果通过Number()转换函数传入一个字符串，它会试图将其转化为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()函数和parseFloat()函数（它们是全局函数，不从属于任何类的方法）更加灵活。parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2-36。 12345678parseInt('1 shinygang') // =&gt; 3parseFloat('3.14 shinygang') // =&gt; 3.14parseInt('-12.33') // =&gt; -12parseInt('0xff') // =&gt; 255parseFloat('.1') // =&gt; 0.1parseInt('.1') // =&gt; NaN，整数不能以'.'开始parseInt('11', 2) // =&gt; 3 (1*2+1)parseInt('ff', 16) // =&gt; 255 (15*16+15) 对象转换为原始值 对象到布尔值的转换非常简单：所有对象(包括数组和函数)都转换为true。对于包装对象亦是如此：new Boolean(false)是一个对象而不是原始值，它江转换为true。 对象到字符串和对象到数字的转换都是通过调用带转换对象的一个方法来完成的。JS对象有两个不同的方法来执行转换：toString()和valueOf()toString():它的作用是返回一个反应这个对象的字符串。默认的toString()方法并不会返回一个有趣的值。1(&#123;x:1&#125;).toString() // =&gt; "[object Object]" 很多类定义了更多特定版本的toString()方法。例如，数组类的toString()方法将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。函数类的toString()方法返回这个函数的实现定义表示方式。日期类定义的toString()方法返回了一个可读的日期和时间字符串。RegExp类定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串。1234[1,2,3].toString() // =&gt; "1,2,3"(function(x)&#123;f(x);&#125;).toString() // =&gt; "function(x)&#123;\n f(x); \n&#125;"/\d/g.toString() // =&gt; "/\\d/g"new Date(2010,0,1).toString() // =&gt; "Fri Jan 01 2010 00:00:00 GMT+0800 (CST)" valueOf():如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身。日期则返回对应毫秒数。3..1、JS中对象到字符串的转换经过了如下这些步骤： 如果对象具有toString()方法，则调用这个方法。如果他返回一个原始值，JS将这个原始值转换为字符串，并返回这个字符串结果。 如果对象没有toString()方法，或这个方法并不返回一个原始值，那么JS会调用valueOf()方法。如果存在这个方法，则JS调用它。如果返回值是原始值，JS将这个值转换为字符串，并返回这个字符串结果。 否则，JS无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。3.2、在对象到数字的转换过程中，JS做了同样的事情，只是它会首先尝试使用valueOf()方法： 如果对象具有valueOf()方法，后者返回一个原始值，则JS将这个原始值转换为数字返回 否则，如果对象具有toString()方法，返回一个原始值，则JS将其转换并返回 否则，JS抛出一个类型异常错误。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>类型转换</tag>
        <tag>运算符</tag>
        <tag>ECMA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fun fact about null]]></title>
    <url>%2F2017%2F05%2F14%2Ffun-fact-about-null%2F</url>
    <content type="text"><![CDATA[最近在看《你不知道的JavaScript》这本书，发现了一些关于null的有趣事实。 众所周知，JavaScript有7种基本类型： null undefined object number string boolean symbol (es6新增) 这7种数据类型中，null表示空值，它也是比较特殊的一个数据类型。 说出来你可能不信，对null进行typeof的结果竟然是。。。1typeof null === "object" // true 欸！！？？（黑人问号脸） 这应该算是JavaScript的一个bug，但是书上说这个bug由来已久，在JavaScript里存在了近20年，也许永远的不会修复，因为这牵涉到太多的web系统，要是修复的话可能会产生更多的bug。 那么问题来了，如何判定一个变量的类型是null呢？（如果typeof运算对其返回object的话） 答案是：需要使用符合条件对齐进行判定：12var a = null;(!a &amp;&amp; typeof a ==="object"); // true null是所有基本类型中唯一的一个假值（也就是说!null===true)，但typeof对它的返回值是object。 还有一个有趣的事实是，虽然function是object的一个子类型，但typeof对其的返回值是function而不是object，至于其他object的子类型，例如Array，就没有这么特殊的待遇了，typeof对它们的返回一律是object。 尽管null是不常使用的一个基本类型，但是一旦用上了，要是不熟悉这个特点的话，调bug可是一件非常痛苦的事情啦。 最后想大家安利这本书《你不知道的JavaScript》，里面讲了好多关于JavaScript的细节问题，如果想要学好JavaScript的话，这些细节可是不容忽视的哦！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解CSS盒子模型]]></title>
    <url>%2F2017%2F05%2F02%2FCSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[理解CSS盒子模型 网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)，CSS盒子模型都具备这些属性，也主要是这些属性。 这些属性我们可以把它转移到我们日常生活中的盒子(箱子)上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同。 标准盒子模型从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 ie 盒子模型从上图可以看到 ie 盒子模型的范围也包括 margin、border、padding、content，和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading。 例：一个盒子的 margin 为 20px，border 为 1px，padding 为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 202+12+102+200=262px、高 202+12102+50=112px，盒子的实际大小为：宽 12+102+200=222px、高 12+102+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 202+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px。 在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。1231、提示：背景应用于由内容和内边距、边框组成的区域。2、提示：内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。3、提示：外边距可以是负值，而且在很多情况下都要使用负值的外边距。 浏览器兼容性一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 那我们开发的时候选择哪中盒子模型呢？肯定是“标准 w3c 盒子模型”。怎么样才算是选择了“标准 w3c 盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。假如不加 doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie 浏览器会采用 ie 盒子模型去解释你的盒子，而 ff 会采用标准 w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型。 CSS3 box-sizing 属性定义和用法box-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素。box-sizing有两个值一个是content-box，另一个是border-box。当设置为box-sizing:content-box时，将采用*标准模式*解析计算，也是默认模式；当设置为box-sizing:border-box时，将采用*怪异模式*解析计算；目前使用此属性需要前缀如下:123-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box|border-box|inherit; 例如，假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 “border-box”。这可令浏览器以怪异模式呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>兼容</tag>
        <tag>CSS</tag>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器内核]]></title>
    <url>%2F2017%2F04%2F26%2F%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[作为一个前端程序员，浏览器是我们每天都要打交道的对象。众所周知，现在市面上有非常多的浏览器产品，而它们的内核也不尽相同，那么到底有那些浏览器内核，而不同的浏览器又使用了什么内核呢？今天我们就来捋一捋。 浏览器内核可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有 10 多种，但是常见的浏览器内核可以分这5种：Trident、Gecko、Presto、Blink、Webkit。 渲染引擎TridentTrident(IE内核)：该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。 由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，微软很长时间都并没有更新Trident内核，这导致了两个后果——一是Trident内核曾经几乎与W3C标准脱节（2005年），二是Trident内核的大量 Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。补充：IE从版本11开始，初步支持WebGL技术。IE8的JavaScript引擎是Jscript，IE9开始用Chakra，这两个版本区别很大，Chakra无论是速度和标准化方面都很出色。 Trident内核的常见浏览器有：IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）； 360安全浏览器（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink）猎豹极轻浏览器，360极速浏览器（7.5之前为Trident+Webkit，7.5为Trident+Blink）猎豹安全浏览器（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink）猎豹极轻浏览器，傲游浏览器（傲游1.x、2.x为IE内核，3.x为IE与Webkit双核）、百度浏览器（早期版本）、世界之窗浏览器（最初为IE内核，2013年采用Chrome+IE内核）、2345浏览器、腾讯TT、淘宝浏览器、采编读浏览器、搜狗高速浏览器（1.x为Trident，2.0及以后版本为Trident+Webkit）、阿云浏览器（早期版本）、瑞星安全浏览器、Slim Browser、 GreenBrowser、爱帆浏览器（12 之前版本）、115浏览器、155浏览器、闪游浏览器、N氧化碳浏览器、糖果浏览器、彩虹浏览器、瑞影浏览器、勇者无疆浏览器、114浏览器、蚂蚁浏览器、飞腾浏览器、速达浏览器、佐罗浏览器、海豚浏览器（iPhone/iPad/Android）、UC浏览器（Blink内核+Trident内核）等。 其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。 PrestoPresto(Opera前内核) (已废弃)： Opera12.17及更早版本曾经采用的内核，现已停止开发并废弃，该内核在2003年的Opera7中首次被使用，该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。 实际上这是一个动态内核，与前面几个内核的最大的区别就在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。此外该内核在执行Javascrīpt的时候有着最快的速度，根据在同等条件下的测试，Presto内核执行同等Javascrīpt所需的时间仅有Trident和Gecko内核的约1/3（Trident内核最慢，不过两者相差没有多大），本文的其中一个修改者认为上述测试信息过于老旧且不完整，因为他曾做过的小测试显示Presto部分快部分慢，各内核总体相当。那次测试的时候因为Apple机的硬件条件和普通PC机不同所以没有测试WebCore内核。只可惜Presto是商业引擎，使用Presto的除开Opera以外，只剩下NDSBrowser、Wii Internet Channle、Nokia 770网络浏览器等，这很大程度上限制了Presto的发展。 Opera现已改用Google Chrome的Blink内核。 GeckoGecko(Firefox内核)：Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。 事实上，Gecko引擎的由来跟IE不无关系，前面说过IE没有使用W3C的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。不过事实上，Gecko 内核的浏览器仍然还是Firefox (火狐) 用户最多，所以有时也会被称为Firefox内核。此外Gecko也是一个跨平台内核，可以在Windows、 BSD、Linux和Mac OS X中使用。 Gecko内核常见的浏览器：[1] Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）、K-Meleon WebkitWebkit(Safari内核,Chrome内核原型,开源):它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。 Webkit引擎包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来，它们都是自由软件，在GPL条约下授权，同时支持BSD系统的开发。所以Webkit也是自由软件，同时开放源代码。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。 限于Mac OS X的使用不广泛和Safari浏览器曾经只是Mac OS X的专属浏览器，这个内核本身应该说市场范围并不大；但似乎根据最新的浏览器调查表明，该浏览器的市场甚至已经超过了Opera的Presto了——当然这一方面得益于苹果转到x86架构之后的人气暴涨，另外也是因为Safari 3终于推出了Windows版的缘故吧。Mac下还有OmniWeb、Shiira等人气很高的浏览器。 Google Chrome、360极速浏览器以及搜狗高速浏览器高速模式也使用Webkit作为内核(在脚本理解方面，Chrome使用自己研发的V8引擎)。WebKit 内核在手机上的应用也十分广泛，例如 Google 的手机 Gphone、 Apple 的iPhone， Nokia’s Series 60 browser 等所使用的 Browser 内核引擎，都是基于 WebKit。 WebKit内核常见的浏览器：傲游浏览器3、Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器 BlinkBlink是一个由Google和Opera Software开发的浏览器排版引擎，Google计划将这个渲染引擎作为Chromium计划的一部分，并且在2013年4月的时候公布了这一消息。这一渲染引擎是开源引擎WebKit中WebCore组件的一个分支，并且在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。 2013年4月3日，谷歌在Chromium Blog上发表博客[3] ，称将与苹果的开源浏览器核心Webkit分道扬镳，在Chromium项目中研发Blink渲染引擎（即浏览器核心），内置于Chrome浏览器之中。 苹果在Safari中采用Webkit核心，并于2005年将Webkit公开为开源软件。谷歌当时采用苹果的Webkit核心打造了Chrome浏览器。Opera也宣布称将会转向Webkit核心，但是谷歌宣布此举后，Opera表示将会跟随谷歌采用其Blink浏览器核心，同时参与了Blink的开发。 谷歌转向研发Blink浏览器内核意义重大，谷歌此举欲降低Webkit即苹果在浏览器市场的影响力。截止2012年底，Webkit浏览器内核占总浏览器市场份额约40%。谷歌解释称，Chromium多处理架构系统与其他Webkit浏览器很不相同。谷歌工程师Adam Barth在博客[3] 中表示，随着浏览器的发展，苹果的Webkit已经不能满足用户需求，同时也有碍浏览器技术的创新步伐。但是他也表示，谷歌自主研发Blink内核绝非易事，但是新内核将会提升整个开源网络生态系统的机能。谷歌做出此举之际，Mozilla与三星也达成合作协议开发“下一代”浏览器渲染引擎Servo。 JS引擎js引擎比较多也比较杂，所以以公司为单位做整理。 第一款JavaScript引擎由布兰登·艾克在网景公司开发，用于Netscape Navigator网页浏览器中。引擎的名字叫做SpiderMonkey，由C实现。它自JavaScript 1.5升级以符合ECMA-262 版本3。Rhino引擎，由网景公司的Norris Boyd开发，由Java实现。像SpiderMonkey一样，Rhino符合ECMA-262 版本3。JavaScript引擎的应用例子还包括： Apple Safari 4的Nitro，Google Chrome的V8和 Mozilla Firefox 3.5的TraceMonkey。 Mozilla SpiderMonkey，第一款JavaScript引擎，由Brendan Eich在Netscape Communications时编写，用于Mozilla Firefox 1.0～3.0版本。 Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写。 TraceMonkey，基于实时编译的引擎，其中部份代码取自Tamarin引擎，用于Mozilla Firefox 3.5～3.6版本。 JaegerMonkey，德文Jäger原意为猎人，结合追踪和组合码技术大幅提高性能，部分技术借凿了V8、JavaScriptCore、WebKit，用于Mozilla Firefox 4.0以上版本。 IonMonkey，可以对JavaScript编译后的结果进行优化，用于Mozilla Firefox 18.0以上版本。 OdinMonkey，可以对asm.js进行优化，用于Mozilla Firefox 22.0以上版本。 GoogleV8，开放源代码，由Google丹麦开发，是Google Chrome的一部分。同时node.js也是使用V8引擎。 微软Chakra (JScript引擎)，中文译名为查克拉，用于Internet Explorer 9的32位版本[1]及Internet Explorer 10。 Opera Linear A，用于Opera 4.0～6.1版本。 Linear B，用于Opera 7.0～9.2版本。 Futhark，用于Opera 9.5～10.2版本。 Carakan，由Opera软件公司编写，自Opera10.50版本开始使用。 其他KJS，KDE的ECMAScript/JavaScript引擎，最初由Harri Porten开发，用于KDE项目的Konqueror网页浏览器中。 Narcissus，开放源代码，由Brendan Eich编写（他也参与编写了第一个SpiderMonkey）。 Tamarin，由Adobe Labs编写，Flash Player 9所使用的引擎。 Nitro（原名SquirrelFish），为Safari 4编写。 当前主流浏览器的渲染引擎和JS引擎当前指的是2017年1月各个浏览器的最新版本。 IE渲染引擎：Trident，JS引擎：Chakra。 edge渲染引擎：edge，JS引擎：Chakra。 firefox渲染引擎：gecko，JS引擎：monkey系列。 safari渲染引擎：webkit，JS引擎：SquirrelFish系列。 Opera渲染引擎：Blink，JS引擎：Carakan。 chrome渲染引擎：Blink，JS引擎：V8。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>内核</tag>
        <tag>Firefox</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码]]></title>
    <url>%2F2017%2F04%2F16%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HTTP状态码的分类以及它们的含义。 概述HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义。 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。 具体分类消息这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。 100 Continue客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 102 Processing由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 成功这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 。 200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。 201 Created请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 Accepted服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 203 Non-Authoritative Information服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 No Content服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 Reset Content服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 Partial Content服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 207 Multi-Status由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 重定向这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。 当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。 300 Multiple Choices被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 302 Move temporarily请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 303 See Other对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 304 Not Modified如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 305 Use Proxy被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 307 Temporary Redirect请求的资源临时从不同的URI 响应请求。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 请求错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400 Bad Request1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401 Unauthorized当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 402 Payment Required该状态码是为了将来可能的需求而预留的。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 405 Method Not Allowed请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 Not Acceptable请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 Proxy Authentication Required与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。 408 Request Timeout请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 Conflict由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 Gone被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 Length Required服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 Precondition Failed服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回414状态码。 415 Unsupported Media Type对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 Requested Range Not Satisfiable如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 Expectation Failed在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421 too many connections从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 Unprocessable Entity请求格式正确，但是由于含有语义错误，无法响应。 423 Locked当前资源被锁定。 424 Failed Dependency由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。 425 Unordered Collection在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 Upgrade Required客户端应当切换到TLS/1.0。（RFC 2817） 449 Retry With由微软扩展，代表请求应当在执行完适当的操作后进行重试。 451 Unavailable For Legal Reasons该请求因法律原因不可用。（RFC 7725） 服务器错误这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 这些状态码适用于任何响应方法。 500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 501 Not Implemented服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 504 Gateway Timeout作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 505 HTTP Version Not Supported服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 Variant Also Negotiates由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 Insufficient Storage服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。 509 Bandwidth Limit Exceeded服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 Not Extended获取资源所需要的策略并没有被满足。 600 Unparseable Response Headers源站没有返回响应头部，只返回实体内容。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS内存泄漏的原因及识别]]></title>
    <url>%2F2017%2F04%2F11%2FJS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概述程序的运行需要内存，只要程序提出要求，操作系统运行时就必须要分配内存。对于持续运行的进程，必须及时释放没用的内存，否则内存占用越来越高，影响系统运行或者直接奔溃。 对于没有再用到的内存，没有及时释放，就叫做内存泄漏。 内存泄漏是每个开发者最终都要面对的问题，它是许多问题的根源：反应迟缓，崩溃，高延迟，以及其他应用问题。 什么是垃圾回收内存可以手动清理，但是很多语言都提供内存自动管理，简化管理内存的代码，这就被称为 垃圾回收机制。 垃圾回收机制如何得知已不再需要的内存？ 引用计数法: 这是一种最常用的方法。语言引擎有一张“引用表”，保存了内存中所有的值的引用次数，当某个值的引用次数为0，就表示这个值已经没有被用到，可以被释放了。 V8 垃圾回收机制自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策 略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）。 导致内存泄露的情况及处理情境一: 某个值没有被用到，但是引用次数不为012var arr = [1,2]console.log('i am dingding') 尽管arr这个变量没有被用到，但是arr的引用次数为1，所以依然会占用内存，如何解除？ 阮大大举了这么一个🌰 123var arr = [1,2]console.log('i am dingding')arr = null arr 被重置，解除了对[1,2]的引用，引用次数就变成了0，内存就可以被释放了。因此，并不是说有了垃圾回收机制，我们就轻松了。你还是需要关注内存占用，对那些很占空间的值，一旦不再用到，你就需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 以上的伪代码，实际情况中，出现的可能性很小很小，为什么？不仅是阮大大举过这个例子，在《JavaScript高级程序设计》中有一个章节也出现过，但是对于前端小菜鸟来说，其实这个栗子实为不妥，原因： all = null ？虽然理论上来说，可行，但是实际编程中不应该是通过这种操作手动清除，一般的编程规范也不会允许你这么去写。去坑的这几年，这种代码我是一行都没写过，因为我不知道要清除内存。。。 arr 是个全局变量？什么情况下我们真的需要定义一个变量在全局作用域下？往往是编程习惯的不妥 一般内存泄漏的情况，大多是在闭包中，函数执行完，但是内部变量依然留在内存中，这就造成了内存泄漏！ 情境二: 意外的全局变量123function fun () &#123; bar = "this is a hidden global variable"&#125; 12345function fun () &#123; this.bar = "potential accident global"&#125;fun () // this 指向window 意外创建了一个全局变量 处理: js文件头部添加&#39;use strict&#39; 开启严格模式解析js，避免创建意外的全局变量 情境三: 脱离DOM的引用 placeholder 情境四: 闭包会引起内存泄漏么 placeholder 内存泄露的识别方法chrome 浏览器 1231. 打开控制台2. 点击Memory3. 勾选Record allocation timeline 命令行 ​ 避免内存泄漏的方法大量引用类型的变量，都需要手动清除，是十分麻烦的，那么有咩有一种引用申明可以让垃圾回收机制不考虑该对象的引用，当其他对象都不再引用该对象，垃圾回收就可自动回收了，所以主要清楚主要的引用就方便很多了。 有的！ ES6考虑到了这点，推出两种新的数据结构 weakSet WeakMap,它们的对于值的引用就是不计入垃圾回收机制 WeakSet WeakSet 是一个构造函数 通过new 创建 成员类型只允许是 =&gt; 对象 1234567const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// WeakSet&#123;[1, 2], [3, 4]&#125;const b = [3, 4];const ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…) 数组b的成员不为对象，所以报错 weakSet 方法 WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 WeakMap类似WeakSet(感觉实际用处并不大，我真的懒得写了 : ) 参考资料:JavaScript 内存泄漏教程4类 JavaScript 内存泄漏及如何避免]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>内存泄漏</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS使用sort方法实现对象数组排序]]></title>
    <url>%2F2017%2F04%2F03%2F%E5%8E%9F%E7%94%9FJS%E4%BD%BF%E7%94%A8sort%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sort 方法接受一个特殊的比较函数作为参数，这个比较函数又有 a, b 两个参数，这两个参数其实就是数组里每一个元素，每次会抽出两个元素进行比较，同时根据比较函数的返回值对这两个元素进行排序，排序有三种情况： 返回值 = 0时，a, b 位置不变 返回值 &lt; 0时，a 排在 b 前面 返回值 &gt; 0时，b 排在 a 前面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 利用sort实现对象数组排序 * 调用: employees.sort( by(param) ) * 函数by: 根据param对对象中对应的键值进行比较，按sort方法的规则返回正负数 * by调用: by( param1, by(param2) ), param1比较结果相同时按param2进行比较 */var employees=[];employees[0]=&#123;name:"George", age:32, retiredate:"March 12, 2014"&#125;;employees[1]=&#123;name:"Edward", age:17, retiredate:"June 2, 2023"&#125;;employees[4]=&#123;name:"Adward", age:17, retiredate:"June 2, 2023"&#125;;employees[2]=&#123;name:"Christine", age:58, retiredate:"December 20, 2036"&#125;;employees[3]=&#123;name:"Sarah", age:62, retiredate:"April 30, 2020"&#125;;var by = function(key, fn) &#123; return function (o,p) &#123; var a,b; if (typeof o === 'object' &amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) &#123; a = o[key]; b = p[key]; if (a === b) &#123; return typeof fn === 'function' ? fn(o,p) : 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125; &#125;;&#125;employees.sort(by('age',by('name')));console.log(employees);/** * 利用sort实现对象数组排序 * 调用: employees.sort( by(param) ) * 函数by: 根据param对对象中对应的键值进行比较，按sort方法的规则返回正负数 * by调用: by( param1, by(param2) ), param1比较结果相同时按param2进行比较 */var employees=[];employees[0]=&#123;name:"George", age:32, retiredate:"March 12, 2014"&#125;;employees[1]=&#123;name:"Edward", age:17, retiredate:"June 2, 2023"&#125;;employees[4]=&#123;name:"Adward", age:17, retiredate:"June 2, 2023"&#125;;employees[2]=&#123;name:"Christine", age:58, retiredate:"December 20, 2036"&#125;;employees[3]=&#123;name:"Sarah", age:62, retiredate:"April 30, 2020"&#125;;var by = function(key, fn) &#123; return function (o,p) &#123; var a,b; if (typeof o === 'object' &amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) &#123; a = o[key]; b = p[key]; if (a === b) &#123; return typeof fn === 'function' ? fn(o,p) : 0; &#125; if (typeof a === typeof b) &#123; return a &lt; b ? -1 : 1; &#125; return typeof a &lt; typeof b ? -1 : 1; &#125; &#125;;&#125;employees.sort(by('age',by('name')));console.log(employees);/*输出：[ &#123; name: 'Adward', age: 17, retiredate: 'June 2, 2023' &#125;, &#123; name: 'Edward', age: 17, retiredate: 'June 2, 2023' &#125;, &#123; name: 'George', age: 32, retiredate: 'March 12, 2014' &#125;, &#123; name: 'Christine', age: 58, retiredate: 'December 20, 2036' &#125;, &#123; name: 'Sarah', age: 62, retiredate: 'April 30, 2020' &#125; ]*/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记-Set和Map]]></title>
    <url>%2F2017%2F04%2F01%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Set%E5%92%8CMap%2F</url>
    <content type="text"><![CDATA[大家知道，在ES5中，我们拥有两种数据数据结构，Array和Object。但是它们的功能还不够全面。于是在ES6中又为我们提供了两个新的数据结构，Set和Map。 Set基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，也展示了一种去除数组重复成员的方法。12// 去除数组的重复成员[...new Set(array)] 向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 要注意的是，两个对象总是被认为是不相等的。1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。12345const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 Map基本用法JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 事实上，不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1const m2 = new Map([['baz', 3]]);const m3 = new Map(m2);m3.get('baz') // 3 WeakMapWeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将数值1和Symbol值作为WeakMap的键名，都会报错。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记-箭头函数]]></title>
    <url>%2F2017%2F03%2F03%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[箭头函数是ES6中一个新增的特性，今天我们就来看看它是如何使用的。 基本用法ES6 允许使用“箭头”（=&gt;）定义函数。1var f = v =&gt; v; 等同于123var f = function(v) &#123; return v;&#125;; 我们可以看到箭头前面的 v 是作为函数的参数，箭头后面的 v 是作为函数的返回值，那么箭头函数的结构差不多就明了了。 如果你不需要参数，或需要多个参数，就使用一个圆括号在参数部分，也就是箭头的前面：12345var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 通过之前的例子我们可以知道，箭头后面的内容就是函数要返回的内容，但这仅限于函数体用一句语句就可以解决的情况，如果函数体拥有一句以上的语句，你需要将函数体中的语句用大括号括起来，并仍然需要使用return语句将返回值返回：1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 如果你想要返回一个对象，必须用括号将这个对象括起来：1var id = x =&gt;(&#123; id : x , name : 'name' &#125;) 箭头函数可以与变量解构结合使用。123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数的作用对于箭头函数的作用，个人认为有三点： 箭头函数使函数的表达更为简洁。 对于简单的一些功能函数，箭头函数相比于传统函数的表达更为简洁，并且代码量也更少，通常只需要一行。 简化回调函数： 1234567 // 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 这样使代码更加简洁也更加易读。 箭头函数可以将this对象绑定在定义时的作用域中，这种特性非常利于封装回调函数： 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 使用箭头函数时要注意 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 这大概就是对箭头函数的大致介绍了，其他的还要小伙伴们自己去探索，祝大家学习愉快哦。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的this用法小结]]></title>
    <url>%2F2017%2F02%2F11%2FJS%E4%B8%AD%E7%9A%84this%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经常能看到关于this的博文，分享等，下面来谈谈前端小菜鸟眼中的this JS中的this关于this的概述，要说的这么一点： 1. this是javascript语言的一个关键字2. 函数运行时，自动生成的一个内部对象，只能在函数内部使用 123function foo () &#123; this.name = 'dingding';&#125; 3. 随着函数使用的不同场合，this指向会发生变化，generally speaking，this指向调用函数的那个对象 this的六种情况使用纯函数调用123456function foo () &#123; this.x = 1; alert(this.x)&#125;foo(); // 1 12345678var x = 1;function bar () &#123; this.x = 0; alert(x);&#125;bar(); // 0 很明显，这里foo在全局作用域下被调用，this指向window，this.x 在函数中被篡改，window.x = 0 因此结果是0 作为对象方法调用12345678var obj = &#123; x: 1, f: function foo ()&#123; alert(this.x); &#125;&#125;obj.f(); // alert 1 当函数作为某个对象的属性被调用,this指向该对象 作为构造函数调用12345678910var x = 2;function foo () &#123; this.x = 0;&#125;var obj = new foo();obj.x // 0window.x // 2 this指向的是构造函数new出来的obj这个新的对象，而不是指向window，因此出现以上结果 call/apply调用apply是函数对象的一个方法，作用就是改变函数的调用 12345678910var x = 2;var obj = &#123; x: 1, f: function foo () &#123; alert(this.x); &#125;&#125;obj.f.apply(); // alert 2obj.f.apply(obj); // alert 1 apply 参数为空 默认的第一个参数（调用该函数的新对象）默认指向window bind调用Function.prototype.bind 举一个🌰 1234567891011121314this.x = 9var module = &#123; x: 81, getX: function() &#123; return this.x &#125;&#125;module.getX() // 81var windowGetX = module.getXwindowGetX() // 9var boundGetX = module.getX.bind(module)() // 81 再来一个🌰 123456789101112var name="DingDing";function Person(name)&#123; this.name=name; this.sayName = function () &#123; setTimeout(function () &#123; console.log("my name is "+this.name); &#125;,50) &#125;&#125;var person=new Person("dingding");person.sayName() // my name is DingDing 怎么才能输出 my name is dingding呢？ ok 方案1: 利用call / apply 改变this 指向window 123person.sayName.call()// orperson.sayName.apply() 方案2: 利用bind修改this指向 123456789101112var name="DingDing";function Person(name)&#123; this.name=name; this.sayName = function () &#123; setTimeout(function () &#123; console.log("my name is "+this.name); &#125;.bind(this),50) &#125;&#125;var person=new Person("dingding");person.sayName() // my name is dingding setTimeout 默认由window修改成指向person 因此 person.name === ‘dingding’ 方案3: 其实我们经常会用到，至少我经常用，就是这么干 12345678910111213var name="DingDing";function Person(name)&#123; this.name=name var that = this this.sayName = function () &#123; setTimeout(function () &#123; console.log("my name is " + that.name); &#125;,50) &#125;&#125;var person=new Person("dingding");person.sayName() // my name is dingding person中的this 已经由that代替，so~ setTimeout 中that.name === ’dingding‘ 蓝鹅 this 依然指向 window，但是又有什么关系呢，我们又不用，是吧！ 箭头函数说到箭头函数，那就比较厉害了！ 箭头函数最大的坑，就是没有this! this固定化，始终指向外部对象。因此，不仅自身不能实例化，也不能用call,apply, bind来改变this指向～ 12345678function Timer() &#123; this.seconds = 0; setInterval( function() &#123;this.seconds ++&#125; , 1000);&#125;var timer = new Timer();setTimeout(function()&#123;console.log(timer.seconds)&#125;, 3000) // 0setInterval( function () &#123; console.log(this.seconds); this.seconds ++&#125; , 1000) 如果把this.seconds打印出来，你会看到 每隔一秒打印一个NaN，因为 setInterval 里的this跟Time内部的this 没有半毛钱关系，所以： 1this.seconds = undefined ++ = NaN 如果我们使用箭头函数呢？会怎么样？ 1234567function Timer() &#123; this.seconds = 0; setInterval( () =&gt; this.seconds ++, 1000);&#125;var timer = new Timer();setTimeout( () =&gt; console.log(timer.seconds), 3000); // 3 构造函数内部的setInterval内的回调函数this始终指向实例化对象 即 timer Fine 关于this 总结的也就是这么几点，其实有时候经常用到的一些东西，真的未必你都能理解，如果真的都理解的，那么你写代码的效率提高的肯定不止一个level!]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Vue.js]]></title>
    <url>%2F2017%2F02%2F02%2FHello-Vue-js%2F</url>
    <content type="text"><![CDATA[Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 起步尝试 Vue.js 最简单的方法是使用 JSFiddle Hello World例子。你可以在浏览器新标签页中打开它，跟着我们学习一些基础示例。或者你也可以创建一个本地的 .html 文件，然后通过如下方式引入 Vue: 1&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt; 你可以查看安装指南来了解其他安装 Vue 的选项。请注意我们不推荐新手直接使用 vue-cli，尤其是对 Node.js 构建工具不够了解的同学。 声明式渲染Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统： 123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) 我们已经生成了我们的第一个 Vue 应用！看起来这跟单单渲染一个字符串模板非常类似，但是 Vue.js 在背后做了大量工作。现在数据和 DOM 已经被绑定在一起，所有的元素都是响应式的。我们如何知道？打开你的浏览器的控制台，并修改 app.message，你将看到上例相应地更新。 除了绑定插入的文本内容，我们还可以采用这样的方式绑定 DOM 元素属性： 123456&lt;div id="app-2"&gt; &lt;span v-bind:title="message"&gt; Hover your mouse over me for a few seconds to see my dynamically bound title! &lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: 'You loaded this page on ' + new Date() &#125;&#125;) 这里我们遇到点新东西。你看到的 v-bind 属性被称为指令。指令带有前缀 v-，以表示它们是 Vue.js 提供的特殊属性。可能你已经猜到了，它们会在渲染过的 DOM 上应用特殊的响应式行为。这个指令的简单含义是说：将这个元素节点的 title 属性和 Vue 实例的 message 属性绑定到一起。 你再次打开浏览器的控制台输入 app2.message = &#39;some new message&#39;，你就会再一次看到这个绑定了title属性的HTML已经进行了更新。 用组件构建（应用）组件系统是 Vue.js 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树： 在 Vue 里，一个组件实质上是一个拥有预定义选项的一个 Vue 实例： 1234// Define a new component called todo-itemVue.component('todo-item', &#123; template: '&lt;li&gt;This is a todo&lt;/li&gt;'&#125;) 现在你可以在另一个组件模板中写入它： 1234&lt;ol&gt; &lt;!-- Create an instance of the todo-item component --&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; 但是这样会为每个 todo 渲染同样的文本，这看起来并不是很酷。我们应该将数据从父作用域传到子组件。让我们来修改一下组件的定义，使得它能够接受一个属性字段： 1234567Vue.component('todo-item', &#123; // The todo-item component now accepts a // "prop", which is like a custom attribute. // This prop is called todo. props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;) 现在，我们可以使用 v-bind 指令将 todo 传到每一个重复的组件中： 1234567&lt;div id="app-7"&gt; &lt;ol&gt; &lt;!-- Now we provide each todo-item with the todo object --&gt; &lt;!-- it's representing, so that its content can be dynamic --&gt; &lt;todo-item v-for="item in groceryList" v-bind:todo="item"&gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 123456789101112131415Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; text: 'Vegetables' &#125;, &#123; text: 'Cheese' &#125;, &#123; text: 'Whatever else humans are supposed to eat' &#125; ] &#125;&#125;) 这只是一个假设的例子，但是我们已经将应用分割成了两个更小的单元，子元素通过 props 接口实现了与父亲元素很好的解耦。我们现在可以在不影响到父应用的基础上，进一步为我们的 todo 组件改进更多复杂的模板和逻辑。 在一个大型应用中，为了使得开发过程可控，有必要将应用整体分割成一个个的组件。在后面的教程中我们将详述组件，不过这里有一个（假想）的例子，看看使用了组件的应用模板是什么样的： 1234567&lt;div id="app"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; 准备好探索更广阔的世界了？ 我们刚才简单介绍了 Vue.js 核心的一些最基本的特征 - 本指南的其余部分将用更详尽的篇幅去描述其他的一些高级特性，所以一定要阅读完所有的内容哦！ 原文：http://vuejs.org/guide/index.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
        <tag>博客</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
